# -*- coding: utf-8 -*-
"""carga_mental_lao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NazZBFv4kiHYdeDaijzH61bauL9iwM32
"""

import streamlit as st
from datetime import date, datetime, time # Importar datetime y time
import uuid
import locale
import json # Necesario para guardar y cargar datos
import os # Necesario para verificar si el archivo existe
import pandas as pd

# --- CONFIGURACI√ìN DE LA PERSISTENCIA ---
# Usaremos un archivo JSON para almacenar datos y configuraci√≥n.
TASKS_FILE = "tasks_data.json"

# --- CONFIGURACI√ìN DEL IDIOMA (M√ÅS ROBUSTA) ---
# Intentamos establecer el locale para que las fechas se muestren en espa√±ol.
locales_to_try = ['es_ES.UTF-8', 'es_ES.utf8', 'es_ES', 'es']
for loc in locales_to_try:
    try:
        locale.setlocale(locale.LC_TIME, loc)
        break
    except locale.Error:
        continue

# --- MAPAS DE TRADUCCI√ìN MANUAL DE SEGURIDAD ---
# Se usan si el setlocale falla y strftime devuelve nombres en ingl√©s.
SPANISH_MONTHS = {
    "January": "Enero", "February": "Febrero", "March": "Marzo", "April": "Abril",
    "May": "Mayo", "June": "Junio", "July": "Julio", "August": "Agosto",
    "September": "Septiembre", "October": "Octubre", "November": "Noviembre", "December": "Diciembre"
}

SPANISH_DAYS = {
    "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
    "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
}

def format_date_in_spanish(date_obj):
    """
    Formatea la fecha a espa√±ol de manera segura (D√≠aSemana, D√≠a de Mes de A√±o).
    """
    date_str = date_obj.strftime("%A, %d de %B de %Y")

    # Capitalizar la primera letra (D√≠a de la semana)
    date_str = date_str.capitalize()

    # Traducci√≥n manual de seguridad si el locale fall√≥
    for en, es in SPANISH_DAYS.items():
        date_str = date_str.replace(en, es).replace(en.lower(), es.lower())

    for en, es in SPANISH_MONTHS.items():
        date_str = date_str.replace(en, es).replace(en.lower(), es.lower())

    return date_str

# --- CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Organizador de Tareas: Carga Mental Cero",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- ESTILOS CSS PERSONALIZADOS ---

CAPTION_STYLE = """
<style>
/* Estilo para los subt√≠tulos de las listas de tareas y calendario, forzando color negro */
div[data-testid="stCaptionContainer"] {
    color: #000000 !important;
}
</style>
"""
st.markdown(CAPTION_STYLE, unsafe_allow_html=True)


# --- CONSTANTES DE CATEGOR√çA Y ESTILOS ---
CATEGORIES = {
    "üî¥ Urgente": {"color": "#FF4B4B", "label": "Urgente"},      # Rojo
    "üü† Importante": {"color": "#FFA500", "label": "Importante"},  # Naranja
    "üü° Pendiente": {"color": "#FFD700", "label": "Pendiente"}   # Amarillo/Dorado
}

# --- FUNCIONES DE CARGA/GUARDADO DE DATOS (PERSISTENCIA) ---

def load_tasks():
    """Carga las tareas y la configuraci√≥n desde el archivo JSON si existe."""
    default_config = {"reminder_time": time(18, 0)} # Por defecto 6:00 PM (18:00)

    if os.path.exists(TASKS_FILE):
        try:
            with open(TASKS_FILE, 'r') as f:
                data = json.load(f)

                tasks = data.get("tasks", [])
                config = data.get("config", {})

                # Convertir las cadenas de fecha ISO de vuelta a objetos date en las tareas
                for task in tasks:
                    if task["date"]:
                        task["date"] = date.fromisoformat(task["date"])

                # Convertir la cadena de tiempo a objeto time en la configuraci√≥n
                if "reminder_time" in config and isinstance(config["reminder_time"], str):
                    h, m = map(int, config["reminder_time"].split(':'))
                    config["reminder_time"] = time(h, m)
                else:
                    config["reminder_time"] = default_config["reminder_time"]

                return tasks, config
        except json.JSONDecodeError:
            st.warning("El archivo de datos est√° corrupto. Se ha iniciado con una lista vac√≠a y configuraci√≥n por defecto.")
            return [], default_config

    return [], default_config

def save_tasks():
    """Guarda las tareas y la configuraci√≥n en el archivo JSON."""

    tasks_to_save = []
    # 1. Pre-procesar tareas (date -> string)
    for task in st.session_state.tasks:
        task_copy = task.copy()
        if task_copy["date"]:
            task_copy["date"] = task_copy["date"].isoformat()
        tasks_to_save.append(task_copy)

    # 2. Pre-procesar configuraci√≥n (time -> string)
    config_to_save = st.session_state.config.copy()
    if "reminder_time" in config_to_save:
        config_to_save["reminder_time"] = config_to_save["reminder_time"].strftime("%H:%M")

    data_to_save = {
        "tasks": tasks_to_save,
        "config": config_to_save
    }

    with open(TASKS_FILE, 'w') as f:
        json.dump(data_to_save, f, indent=4)

# --- INICIALIZACI√ìN DEL ESTADO DE SESI√ìN ---
# Inicializa tareas y configuraci√≥n (incluida la hora de recordatorio)
if 'tasks' not in st.session_state or 'config' not in st.session_state:
    loaded_tasks, loaded_config = load_tasks()
    st.session_state.tasks = loaded_tasks
    st.session_state.config = loaded_config

# --- FUNCIONES AUXILIARES ---

def set_reminder_time(new_time):
    """Actualiza la hora del recordatorio en la configuraci√≥n y guarda."""
    st.session_state.config["reminder_time"] = new_time
    save_tasks()

def remove_task(task_id):
    """Elimina una tarea por su ID y guarda los cambios."""
    # El task_id debe ser un string v√°lido (UUID)
    st.session_state.tasks = [task for task in st.session_state.tasks if task["id"] != task_id]
    save_tasks() # Guardar despu√©s de eliminar

def add_task(description, category_key, due_date):
    """Agrega una nueva tarea y guarda los cambios."""
    if description:
        category_name = CATEGORIES[category_key]["label"]

        new_task = {
            "id": str(uuid.uuid4()),
            "description": description,
            "category": category_name,
            "category_key": category_key,
            "date": due_date # date object or None
        }
        st.session_state.tasks.append(new_task)
        st.session_state.new_task_description = ""
        st.success("¬°Tarea agregada exitosamente!")
        save_tasks() # Guardar despu√©s de agregar
    else:
        st.error("La descripci√≥n de la tarea no puede estar vac√≠a.")

def update_task_date(task_id, new_date):
    """Actualiza la fecha de una tarea por su ID."""
    for i, t in enumerate(st.session_state.tasks):
        if t["id"] == task_id:
            st.session_state.tasks[i]["date"] = new_date
            save_tasks()
            return True
    return False

def move_task_to_calendar_callback(task_id):
    """
    Callback ejecutado al presionar 'Mover a Calendario'.
    Lee la fecha del st.date_input asociado y actualiza la tarea.
    """
    date_key = f"popover_date_{task_id}"
    new_date = st.session_state.get(date_key)

    if new_date:
        if update_task_date(task_id, new_date):
            pass

# --- L√ìGICA DE CLASIFICACI√ìN ---

def get_tasks_by_status():
    """Clasifica las tareas en listas sin fecha y tareas con fecha (calendario)."""

    tasks_no_date = {data["label"]: [] for data in CATEGORIES.values()}
    tasks_with_date = []

    for task in st.session_state.tasks:
        cat_label = CATEGORIES[task["category_key"]]["label"]
        if task["date"] is None:
            tasks_no_date[cat_label].append(task)
        else:
            tasks_with_date.append(task)

    tasks_with_date.sort(key=lambda x: x["date"])

    return tasks_no_date, tasks_with_date

# --- UI: ENTRADA DE TAREAS (SIDEBAR) ---

with st.sidebar:
    st.title("‚ûï Organiza tu Carga Mental")
    st.markdown("---")

    st.header("Configuraci√≥n de Recordatorio")
    st.warning(
        "**NOTA:** Streamlit no puede enviar recordatorios externos (emails/notificaciones). "
        "Esta opci√≥n guarda tu hora preferida para que puedas revisar la app diariamente."
    )

    # UI para establecer la hora del recordatorio
    current_reminder_time = st.session_state.config.get("reminder_time", time(18, 0))

    # Input de tiempo
    new_reminder_time = st.time_input(
        "Hora diaria de Recordatorio (Hora Local):",
        value=current_reminder_time,
        key="reminder_time_input"
    )

    # Actualizar la hora si ha cambiado
    if new_reminder_time != current_reminder_time:
        set_reminder_time(new_reminder_time)

    st.markdown("---")

    st.header("Nueva Tarea")

    # 1. Descripci√≥n de la tarea
    description = st.text_input(
        "1. Describe la tarea:",
        key="new_task_description",
        placeholder="Ejemplo: Preparar informe mensual"
    )

    # 2. Nivel de Urgencia
    category = st.radio(
        "2. Nivel de urgencia:",
        options=CATEGORIES.keys(),
        index=1, # Por defecto 'Importante'
        horizontal=True,
        key="new_task_category"
    )

    # 3. Fecha espec√≠fica (Opcional)
    has_date = st.checkbox("¬øTiene fecha espec√≠fica?", key="has_date_checkbox")
    due_date = None
    if has_date:
        due_date = st.date_input("3. Elige la fecha:", min_value=date.today(), key="new_task_date")

    # Bot√≥n para agregar la tarea
    st.button(
        "Guardar Tarea",
        on_click=add_task,
        args=(description, category, due_date if has_date else None),
        type="primary",
        use_container_width=True
    )
    st.markdown("---")
    st.markdown("ü§ñ **Objetivo:** Disminuir tu carga mental al visualizar y clasificar tus compromisos.")

# --- UI: PANTALLA PRINCIPAL ---

# Obtener tareas clasificadas
tasks_no_date, tasks_with_date = get_tasks_by_status()

st.title("üìÖ Panel de Tareas")

# --- WIDGET DE ESTADO DEL RECORDATORIO ---
now = datetime.now()
current_time_readable = now.strftime("%H:%M")
reminder_time_obj = st.session_state.config["reminder_time"]
reminder_time_str = reminder_time_obj.strftime("%H:%M")

# Comprobar si es hora de recordatorio (dentro de la misma hora)
# Se comprueba si la hora actual es IGUAL o MAYOR a la hora de recordatorio.
is_reminder_time = now.hour == reminder_time_obj.hour and now.minute >= reminder_time_obj.minute

if is_reminder_time:
    reminder_status_icon = "üîî"
    reminder_message = f"**¬°HORA DE REVISI√ìN!** Son las {current_time_readable}. Revisa tu lista de tareas pendientes para asignar fechas."
    reminder_box_style = "background-color: #FFFFAA; border: 2px solid #FFA500; padding: 10px; border-radius: 8px; margin-bottom: 20px;"
else:
    reminder_status_icon = "üïí"
    reminder_message = f"Recordatorio de revisi√≥n activo: Todos los d√≠as a las **{reminder_time_str}** (Hora Local). Hora actual: {current_time_readable}."
    reminder_box_style = "background-color: #e6f7ff; border: 1px solid #99d6ff; padding: 10px; border-radius: 8px; margin-bottom: 20px;"

st.markdown(
    f'<div style="{reminder_box_style}">{reminder_status_icon} {reminder_message}</div>',
    unsafe_allow_html=True
)
# --- FIN DEL WIDGET ---

# --- SECCI√ìN 1: TAREAS POR ASIGNAR (LISTAS POR CATEGOR√çA) ---

st.header("Lista de Tareas Pendientes (Sin Fecha Asignada)")
st.caption("Estas tareas necesitan que les asignes una fecha para moverlas al calendario.")

# Crear tres columnas para las listas de tareas
col1, col2, col3 = st.columns(3)

def display_task_list(column, category_label, tasks):
    """Muestra una lista de tareas en una columna con el estilo de su categor√≠a."""
    category_data = next((v for k, v in CATEGORIES.items() if v["label"] == category_label), None)
    color = category_data["color"] if category_data else "#CCCCCC"

    with column:
        # Estilo para el encabezado de la lista
        st.markdown(
            f"""
            <div style="background-color: {color}; padding: 10px; border-radius: 8px 8px 0 0; color: white; text-align: center; font-weight: bold;">
                {category_label.upper()} ({len(tasks)})
            </div>
            """,
            unsafe_allow_html=True
        )

        if not tasks:
            st.info("¬°No hay tareas en esta categor√≠a!")

        for task in tasks:
            # Contenedor principal de la tarea
            st.markdown(
                f"""
                <div style="border: 1px solid {color}; border-radius: 0 0 8px 8px; margin-top: -1px; padding: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="flex-grow: 1; margin-right: 10px;">{task['description']}</span>
                </div>
                """,
                unsafe_allow_html=True
            )

            # Contenedor para los botones (popover y eliminar)
            col_popover, col_btn_del = st.columns([4, 1])

            with col_btn_del:
                # Bot√≥n de eliminar - **CORRECCI√ìN APLICADA AQU√ç**
                st.button(
                    "üóëÔ∏è",
                    key=f"del_no_date_{task['id']}",
                    on_click=lambda task_id=task['id']: remove_task(task_id), # Usa lambda para forzar la captura del ID
                    help="Eliminar tarea"
                    # Eliminado args=(task['id'],)
                )

            with col_popover:
                # Popover para mover al calendario
                with st.popover("üìÖ Asignar fecha", use_container_width=True):
                    # Input de fecha, cuyo valor se guarda en el estado de sesi√≥n
                    st.date_input(
                        "Selecciona una fecha para esta tarea:",
                        min_value=date.today(),
                        key=f"popover_date_{task['id']}"
                    )

                    # Bot√≥n que llama al callback para leer la fecha del input y mover la tarea
                    st.button(
                        "Mover a Calendario",
                        key=f"move_to_cal_{task['id']}",
                        on_click=move_task_to_calendar_callback,
                        args=(task['id'],),
                        type="primary",
                        use_container_width=True
                    )

# Mostrar las tres listas
display_task_list(col1, "Urgente", tasks_no_date["Urgente"])
display_task_list(col2, "Importante", tasks_no_date["Importante"])
display_task_list(col3, "Pendiente", tasks_no_date["Pendiente"])

st.markdown("---")

# --- SECCI√ìN 2: CALENDARIO (TAREAS ASIGNADAS) ---

st.header("üóìÔ∏è Calendario")
# Se incluye el subt√≠tulo din√°mico con el color de letra forzado a negro
st.caption(f"Tienes **{len(tasks_with_date)}** tareas programadas.")

if not tasks_with_date:
    st.info("¬°No tienes tareas con fecha espec√≠fica a√∫n! Agr√©galas o as√≠gnales una fecha desde las listas.")
else:
    # Agrupar las tareas por fecha
    tasks_by_date = {}
    for task in tasks_with_date:
        # USANDO LA FUNCI√ìN DE FORMATO EN ESPA√ëOL DE SEGURIDAD
        date_str = format_date_in_spanish(task["date"])
        if date_str not in tasks_by_date:
            tasks_by_date[date_str] = []
        tasks_by_date[date_str].append(task)

    for date_str, tasks in tasks_by_date.items():
        # Ordenar tareas dentro del d√≠a por nivel de urgencia para destacar la m√°s importante
        tasks.sort(key=lambda t: list(CATEGORIES.keys()).index(t['category_key']))
        top_color = CATEGORIES[tasks[0]['category_key']]['color']

        # Expander (el contenedor del d√≠a)
        with st.expander(f"**{date_str}** ({len(tasks)} Tareas)", expanded=True):
            # Inyectar CSS para el borde del expander
            st.markdown(
                f'<style>.stExpanderDetails {{ border-left: 5px solid {top_color}; padding-left: 10px; }}</style>',
                unsafe_allow_html=True
            )
            for task in tasks:
                color = CATEGORIES[task["category_key"]]["color"]

                # Dise√±o de tarjeta para cada tarea en el calendario
                col_desc, col_complete, col_btn_del = st.columns([4, 1, 1])

                with col_desc:
                    # Tarjeta de descripci√≥n con barra lateral de color
                    st.markdown(
                        f"""
                        <div style="background-color: #f0f2f6; border-left: 5px solid {color}; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; align-items: center;">
                            <strong style="margin-right: 10px;">{task['category_key'].split(' ')[0]}</strong>
                            <span>{task['description']}</span>
                        </div>
                        """,
                        unsafe_allow_html=True
                    )

                # --- BOT√ìN: MARCAR COMO COMPLETADA - **CORRECCI√ìN APLICADA AQU√ç** ---
                with col_complete:
                    st.button(
                        "‚úÖ",
                        key=f"complete_{task['id']}",
                        on_click=lambda task_id=task['id']: remove_task(task_id), # Usa lambda para forzar la captura del ID
                        help="Marcar como realizada (Completar)",
                        type="secondary"
                        # Eliminado args=(task['id'],)
                    )

                with col_btn_del:
                    # --- BOT√ìN: ELIMINAR TAREA - **CORRECCI√ìN APLICADA AQU√ç** ---
                    st.button(
                        "üóëÔ∏è",
                        key=f"del_date_{task['id']}",
                        on_click=lambda task_id=task['id']: remove_task(task_id), # Usa lambda para forzar la captura del ID
                        help="Eliminar tarea"
                        # Eliminado args=(task['id'],)
                    )